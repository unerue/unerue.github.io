Traceback (most recent call last):
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\asyncio\base_events.py", line 647, in run_until_complete
    return future.result()
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\unerue\miniconda3\envs\jupyterbook\lib\site-packages\nbclient\client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from skimage import io, data, color, transform, feature, segmentation, util


def _generate_segments(image, scale, sigma, min_size):
    """Segment smallest regions by the algorithm of Felzenswalb and Huttenlocher
    
    Args:
        image: an original image
    """
    # open the Image
    mask = segmentation.felzenszwalb(
        util.img_as_float(image), scale=scale, sigma=sigma, min_size=min_size
    )

    # merge mask channel to the image as a 4th channel
    image = np.append(image, np.zeros(image.shape[:2])[:, :, np.newaxis], axis=2)
    image[:, :, 3] = mask

    return image


def _similarity_color(r1, r2):
    """Calculate the sum of histogram intersection of colour"""
    return sum([min(a, b) for a, b in zip(r1["hist_c"], r2["hist_c"])])


def _similarity_texture(r1, r2):
    """Calculate the sum of histogram intersection of texture"""
    return sum([min(a, b) for a, b in zip(r1["hist_t"], r2["hist_t"])])


def _similarity_size(r1, r2, imsize):
    """Calculate the size similarity over the image"""
    return 1.0 - (r1["size"] + r2["size"]) / imsize


def _similarity_fill(r1, r2, imsize):
    """Calculate the fill similarity over the image"""
    bbsize = (
        (max(r1["max_x"], r2["max_x"]) - min(r1["min_x"], r2["min_x"]))
        * (max(r1["max_y"], r2["max_y"]) - min(r1["min_y"], r2["min_y"]))
    )
    return 1.0 - (bbsize - r1["size"] - r2["size"]) / imsize


def _calc_similarity(r1, r2, imsize):
    return (
        _similarity_color(r1, r2) + _similarity_texture(r1, r2)
        + _similarity_size(r1, r2, imsize) + _similarity_fill(r1, r2, imsize)
    )


def _calc_colour_hist(image, num_channels=3, bins=25):
    """Calculate colour histogram for each region the size of output 
    histogram will be BINS * COLOUR_CHANNELS(3) number of bins is 25 
    as same as [uijlings_ijcv2013_draft.pdf] extract HSV
    """
    hist = np.array([])
    for channel in range(num_channels):
        # extracting one colour channel
        c = image[:, channel]
        # calculate histogram for each colour and join to the result
        hist = np.concatenate(
            [hist] + [np.histogram(c, bins, (0.0, 255.0))[0]]
        )
    # L1 normalize
    hist = hist / len(image)

    return hist


def _calc_texture_gradient(image):
    """
        calculate texture gradient for entire image
        The original SelectiveSearch algorithm proposed Gaussian derivative
        for 8 orientations, but we use LBP instead.
        output will be [height(*)][width(*)]
    """
    ret = np.zeros((image.shape[0], image.shape[1], image.shape[2]))
    for channel in (0, 1, 2):
        ret[:, :, channel] = feature.local_binary_pattern(
            img[:, :, channel], P=8, R=1.0
        )

    return ret


def _calc_texture_hist(image, num_channels=3, bins=10):
    """
        calculate texture histogram for each region
        calculate the histogram of gradient for each colours
        the size of output histogram will be
            BINS * ORIENTATIONS * COLOUR_CHANNELS(3)
    """
    hist = np.array([])
    for channel in range(num_channels):
        # mask by the color channel
        fd = image[:, channel]
        # calculate histogram for each orientation and concatenate them all
        # and join to the result
        hist = np.concatenate(
            [hist] + [np.histogram(fd, bins, (0.0, 1.0))[0]]
        )
    # L1 Normalize
    hist = hist / len(image)

    return hist


def _extract_regions(img):
    regions = {}
    # get hsv image
    hsv = color.rgb2hsv(img[:, :, :3])
    # pass 1: count pixel positions
    for y, i in enumerate(img):
        for x, (r, g, b, l) in enumerate(i):
            # initialize a new region
            if l not in regions:
                regions[l] = {
                    "min_x": 0xffff, "min_y": 0xffff,
                    "max_x": 0, "max_y": 0, "labels": [l]
                }
            # bounding box
            if regions[l]["min_x"] > x:
                regions[l]["min_x"] = x
            elif regions[l]["min_y"] > y:
                regions[l]["min_y"] = y
            elif regions[l]["max_x"] < x:
                regions[l]["max_x"] = x
            elif regions[l]["max_y"] < y:
                regions[l]["max_y"] = y

    # pass 2: calculate texture gradient
    tex_grad = _calc_texture_gradient(img)
    # pass 3: calculate colour histogram of each region
    for k, v in list(regions.items()):
        # colour histogram
        masked_pixels = hsv[:, :, :][img[:, :, 3] == k]
        regions[k]["size"] = len(masked_pixels / 4)
        regions[k]["hist_c"] = _calc_colour_hist(masked_pixels)
        # texture histogram
        regions[k]["hist_t"] = _calc_texture_hist(tex_grad[:, :][img[:, :, 3] == k])

    return regions


def _extract_neighbours(regions):
    def intersect(a, b):
        if (a["min_x"] < b["min_x"] < a["max_x"]
                and a["min_y"] < b["min_y"] < a["max_y"]) or (
            a["min_x"] < b["max_x"] < a["max_x"]
                and a["min_y"] < b["max_y"] < a["max_y"]) or (
            a["min_x"] < b["min_x"] < a["max_x"]
                and a["min_y"] < b["max_y"] < a["max_y"]) or (
            a["min_x"] < b["max_x"] < a["max_x"]
                and a["min_y"] < b["min_y"] < a["max_y"]):
            return True
        return False

    R = list(regions.items())
    neighbours = []
    for cur, a in enumerate(R[:-1]):
        for b in R[cur + 1:]:
            if intersect(a[1], b[1]):
                neighbours.append((a, b))

    return neighbours


def _merge_regions(r1, r2):
    new_size = r1["size"] + r2["size"]
    rt = {
        "min_x": min(r1["min_x"], r2["min_x"]),
        "min_y": min(r1["min_y"], r2["min_y"]),
        "max_x": max(r1["max_x"], r2["max_x"]),
        "max_y": max(r1["max_y"], r2["max_y"]),
        "size": new_size,
        "hist_c": (
            r1["hist_c"] * r1["size"] + r2["hist_c"] * r2["size"]) / new_size,
        "hist_t": (
            r1["hist_t"] * r1["size"] + r2["hist_t"] * r2["size"]) / new_size,
        "labels": r1["labels"] + r2["labels"]
    }
    return rt


class SelectiveSearch:
    """Selective Search

    Args:
        im_orig : ndarray
            Input image
        scale : int
            Free parameter. Higher means larger clusters in felzenszwalb segmentation.
        sigma : float
            Width of Gaussian kernel for felzenszwalb segmentation.
        min_size : int
            Minimum component size for felzenszwalb segmentation.

    Returns:
        img : ndarray
            image with region label
            region label is stored in the 4th value of each pixel [r,g,b,(region)]
        regions : array of dict
            [
                {
                    'rect': (left, top, width, height),
                    'labels': [...],
                    'size': component_size
                },
                ...
            ]
    
    """
    def __init__(self, scale=1.0, sigma=0.8, min_size=50):
        self.scale = scale
        self.sigma = sigma
        self.min_size = min_size
        
    def __call__(self, image):
        assert image.shape[2] == 3, 'An image is expected to be 3 channels'
        image = _generate_segments(image, self.scale, self.sigma, self.min_size)
        image_size = image.shape[0] * image.shape[1]
        regions = _extract_regions(image)
        # extract neighbouring information
        neighbours = _extract_neighbours(regions)
        # calculate initial similarities
        similarities = {}
        for (ai, ar), (bi, br) in neighbours:
            similarities[(ai, bi)] = _calc_similarity(ar, br, image_size)

        # hierarchal search
        while similarities != {}:
            # get highest similarity
            i, j = sorted(similarities.items(), key=lambda i: i[1])[-1][0]
            # merge corresponding regions
            t = max(regions.keys()) + 1.0
            regions[t] = _merge_regions(regions[i], regions[j])
            # mark similarities for regions to be removed
            key_to_delete = []
            for k, v in list(similarities.items()):
                if (i in k) or (j in k):
                    key_to_delete.append(k)
            # remove old similarities of related regions
            for k in key_to_delete:
                del similarities[k]
            # calculate similarity set with the new region
            for k in [a for a in key_to_delete if a != (i, j)]:
                n = k[1] if k[0] in (i, j) else k[0]
                similarities[(t, n)] = _calc_similarity(regions[t], regions[n], image_size)

        boxes = []
        for k, r in list(regions.items()):
            boxes.append({
                'boxes': (
                    r['min_x'], r['min_y'], 
                    r['max_x'] - r['min_x'], r['max_y'] - r['min_y']),
#                     r['min_x'], r['min_y'], r['max_x'], r['max_y']
                'size': r['size'],
                'labels': r['labels']
            })
            
        candidates = set()
        for r in boxes:
            # excluding same rectangle (with different segments)
            if r['boxes'] in candidates:
                continue
            # excluding regions smaller than 2000 pixels
            if r['size'] < 1000:
                continue
            # distorted rects
            x, y, w, h = r['boxes']
            if w / h > 1.2 or h / w > 1.2:
                continue
            candidates.add(r['boxes'])

#         return image, boxes
        return image, candidates
------------------

[1;31m---------------------------------------------------------------------------[0m
[1;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [1;32mIn[1], line 1[0m
[1;32m----> 1[0m [38;5;28;01mimport[39;00m [38;5;21;01mnumpy[39;00m [38;5;28;01mas[39;00m [38;5;21;01mnp[39;00m
[0;32m      2[0m [38;5;28;01mimport[39;00m [38;5;21;01mmatplotlib[39;00m[38;5;21;01m.[39;00m[38;5;21;01mpyplot[39;00m [38;5;28;01mas[39;00m [38;5;21;01mplt[39;00m
[0;32m      3[0m [38;5;28;01mfrom[39;00m [38;5;21;01mmatplotlib[39;00m[38;5;21;01m.[39;00m[38;5;21;01mpatches[39;00m [38;5;28;01mimport[39;00m Rectangle

[1;31mModuleNotFoundError[0m: No module named 'numpy'
ModuleNotFoundError: No module named 'numpy'

