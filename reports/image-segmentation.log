Traceback (most recent call last):
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\jupyter_cache\executors\utils.py", line 51, in single_nb_execution
    executenb(
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "C:\Users\unerue\miniconda3\envs\vision\lib\asyncio\base_events.py", line 642, in run_until_complete
    return future.result()
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import cv2
import numpy as np

# ì´ë¯¸ì§€ ì½ê¸°
img = cv2.imread('../img/coins_connected.jpg')
rows, cols = img.shape[:2]
cv2.imshow('original', img)


# ë™ì „ í‘œë©´ì„ íë¦¿í•˜ê²Œ í”¼ë¼ë¯¸ë“œí‰ê· ì‹œí”„íŠ¸ ì ìš©
mean = cv2.pyrMeanShiftFiltering(img, 20, 50)
cv2.imshow('mean', mean)
# ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ ë³€í™˜
gray = cv2.cvtColor(mean, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (3,3), 0)

_, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
cv2.imshow('thresh', thresh)
# ê±°ë¦¬ ë³€í™˜
dst = cv2.distanceTransform(thresh, cv2.DIST_L2, 3)
# ê±°ë¦¬ ê°’ì„ 0 ~255ë¡œ ë³€í™˜
dst = ( dst / (dst.max() - dst.min()) * 255 ).astype(np.uint8)
cv2.imshow('dst', dst)

# ê±°ë¦¬ ë³€í™˜ê²°ê³¼ì—ì„œ ë¡œì¹¼ ìµœëŒ€ ê°’ êµ¬í•˜ê¸°
## íŒ½ì°½ ì ìš©(ë™ì „ í¬ê¸° ì •ë„ì˜ êµ¬ì¡°í™” ìš”ì†Œ í•„ìš”),
localMx = cv2.dilate(dst, np.ones((50,50), np.uint8))
## ë¡œì¹¼ ìµœëŒ€ ê°’ ì €ì¥ í•  ë°°ì—´ ìƒì„±
lm = np.zeros((rows, cols), np.uint8)
## íŒ½ì°½ ì ìš©ì „ ì´ë¯¸ì§€ì™€ ê°™ì€ í”½ì…€ì´ ë¡œì»¬ ìµœëŒ€ ê°’ì´ë¯€ë¡œ 255ë¡œ ì„¤ì •
lm[(localMx==dst) & (dst != 0)] = 255
cv2.imshow('localMx', lm)

# ë¡œì»¬ ìµœëŒ€ê°’ìœ¼ë¡œ ìƒ‰ ì±„ìš°ê¸°
## ë¡œì»¬ ìµœëŒ€ ê°’ì´ ìˆëŠ” ì¢Œí‘œ êµ¬í•˜ê¸°
seeds = np.where(lm ==255)
seed = np.stack( (seeds[1], seeds[0]), axis=-1)
## ìƒ‰ ì±„ìš°ê¸°ë¥¼ ìœ„í•œ ì±„ìš°ê¸° ë§ˆìŠ¤í¬ ìƒì„±
fill_mask = np.zeros((rows+2, cols+2), np.uint8)
for x,y in seed:
    ## ë¡œì¹¼ ìµœëŒ€ê°’ì„ ì‹œë“œë¡œí•´ì„œ í‰ê·  ì‹œí”„íŠ¸ ì˜ìƒì— ìƒ‰ì±„ìš°ê¸° 
    ret = cv2.floodFill(mean, fill_mask, (x,y), (255,255,255), \
                                            (10,10,10), (10,10,10))
cv2.imshow('floodFill', mean)

# ìƒ‰ ì±„ìš°ê¸° ì ìš©í•œ ì˜ìƒì— ë‹¤ì‹œ ê±°ë¦¬ ë³€í™˜ ì ìš©
gray = cv2.cvtColor(mean, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (5,5), 0)

ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
dst = cv2.distanceTransform(thresh, cv2.DIST_L2, 5)
dst = ( (dst / (dst.max() - dst.min())) * 255 ).astype(np.uint8)
cv2.imshow('dst2', dst)

# ê±°ë¦¬ ë³€í™˜ ê²°ê³¼ê°’ì˜ ì ˆë°˜ ì´ìƒì„ ì°¨ì§€í•œ ì˜ì—­ì€ í™•ì‹¤í•œ ì „ê²½ìœ¼ë¡œ ì„¤ì •
ret, sure_fg = cv2.threshold(dst, 0.5*dst.max(), 255,0)
cv2.imshow('sure_fg', sure_fg)

# ê±°ë¦¬ ë³€í™˜ ê²°ê³¼ë¥¼ ë°˜ì „í•´ì„œ í™•ì‹¤í•œ ë°°ê²½ ì°¾ê¸°
_, bg_th = cv2.threshold(dst, 0.3*dst.max(),  255, cv2.THRESH_BINARY_INV)
bg_dst = cv2.distanceTransform(bg_th, cv2.DIST_L2, 5)
bg_dst = ( (bg_dst / (bg_dst.max() - bg_dst.min())) * 255 ).astype(np.uint8)
ret, sure_bg = cv2.threshold(bg_dst, 0.3*bg_dst.max(), 255,cv2.THRESH_BINARY)
cv2.imshow('sure_bg', sure_bg)


# ë¶ˆí™•ì‹¤í•œ ì˜ì—­ ì„¤ì • : í™•ì‹¤í•œ ë°°ê²½ì„ ë°˜ì „í•´ì„œ í™•ì‹¤í•œ ì „ê²½ì„ ë¹¼ê¸°
ret, inv_sure_bg = cv2.threshold(sure_bg, 127, 255,cv2.THRESH_BINARY_INV)
unkown = cv2.subtract(inv_sure_bg, sure_fg)
cv2.imshow('unkown', unkown)

# ì—°ê²°ëœ ìš”ì†Œ ë ˆì´ë¸”ë§
_, markers = cv2.connectedComponents(sure_fg)

# ë ˆì´ë¸”ë§ì„ 1ì”© ì¦ê°€ ì‹œí‚¤ê³  0ë²ˆ ë ˆì´ë¸” ì•Œ ìˆ˜ ì—†ëŠ” ì˜ì—­ì„ 0ë²ˆ ë ˆì´ë¸”ë¡œ ì„¤ì •
markers = markers+1
markers[unkown ==255] = 0
print("ì›Œí„°ì‰ë“œ ì „:", np.unique(markers))
colors = []
marker_show = np.zeros_like(img)
for mid in np.unique(markers): # ì„ íƒí•œ ë§ˆì»¤ ì•„ì´ë”” ê°¯ìˆ˜ ë§Œí¼ ë°˜ë³µ
    color = [int(j) for j in np.random.randint(0,255, 3)]
    colors.append((mid, color))
    marker_show[markers==mid] = color
    coords = np.where(markers==mid)
    x, y = coords[1][0], coords[0][0]
    cv2.putText(marker_show, str(mid), (x+20, y+20), cv2.FONT_HERSHEY_PLAIN, \
                                                             2, (255,255,255))
cv2.imshow('before', marker_show)

# ë ˆì´ë¸”ë§ì´ ì™„ì„±ëœ ë§ˆì»¤ë¡œ ì›Œí„° ì‰ë“œ ì ìš©
markers = cv2.watershed(img, markers)
print("ì›Œí„°ì‰ë“œ í›„:", np.unique(markers))

for mid, color in colors: # ì„ íƒí•œ ë§ˆì»¤ ì•„ì´ë”” ê°¯ìˆ˜ ë§Œí¼ ë°˜ë³µ
    marker_show[markers==mid] = color
    coords = np.where(markers==mid)
    if coords[0].size <= 0 : 
        continue
    x, y = coords[1][0], coords[0][0]
    cv2.putText(marker_show, str(mid), (x+20, y+20), cv2.FONT_HERSHEY_PLAIN, \
                                                             2, (255,255,255))
marker_show[markers==-1] = (0,255,0)
cv2.imshow('watershed marker', marker_show)

img[markers==-1] = (0,255,0)
cv2.imshow('watershed', img)

# ë™ì „ ì¶”ì¶œì„ ìœ„í•œ ë§ˆìŠ¤í‚¹ ìƒì„±
mask = np.zeros((rows, cols), np.uint8)
# ë°°ê²½ ë§ˆìŠ¤í¬ ìƒì„±
mask[markers!=1] = 255
# ë°°ê²½ ì§€ìš°ê¸°
nobg = cv2.bitwise_and(img, img, mask=mask)
# ë™ì „ë§Œ ìˆëŠ” ë¼ë²¨ ìƒì„± (ë°°ê²½(1), ê²½ê³„(-1) ì—†ëŠ”)
coin_label = [l for l in np.unique(markers) if (l != 1 and l !=-1)]
# ë™ì „ ë¼ë²¨ ìˆœíšŒ í•˜ë©´ì„œ ë™ì „ ì˜ì—­ë§Œ ì¶”ì¶œ
for i, label in enumerate(coin_label):
    mask[:,:] = 0
    # í•´ë‹¹ ë™ì „ ì¶”ì¶œ ë§ˆìŠ¤í¬ ìƒì„±
    mask[markers ==label] = 255
    # ë™ì „ ì˜ì—­ë§Œ ë§ˆìŠ¤í¬ë¡œ ì¶”ì¶œ
    coins = cv2.bitwise_and(img, img, mask=mask)
    # ë™ì „ í•˜ë‚˜ë§Œ ìˆëŠ” ê³³ì—ì„œ ìµœì™¸ê³½ ì»¨íˆ¬ì–´ ì¶”ì¶œ
    _, contour, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,\
                                         cv2.CHAIN_APPROX_NONE)
    # ë™ì „ì„ ê°ì‹¸ëŠ” ì‚¬ê°í˜• ì¢Œí‘œ
    x,y,w,h = cv2.boundingRect(contour[0])
    # ë™ì „ ì˜ì—­ë§Œ ì¶”ì¶œí•´ì„œ ì¶œë ¥
    coin = coins[y:y+h, x:x+w]
    cv2.imshow('coin%d'%(i+1), coin)
    cv2.imwrite('../img/coin_test/coin%d.jpg'%(i+1), coin)
cv2.waitKey()
cv2.destroyAllWindows()
------------------

[1;31m---------------------------------------------------------------------------[0m
[1;31mAttributeError[0m                            Traceback (most recent call last)
Input [1;32mIn [15][0m, in [0;36m<cell line: 6>[1;34m()[0m
[0;32m      4[0m [38;5;66;03m# ì´ë¯¸ì§€ ì½ê¸°[39;00m
[0;32m      5[0m img [38;5;241m=[39m cv2[38;5;241m.[39mimread([38;5;124m'[39m[38;5;124m../img/coins_connected.jpg[39m[38;5;124m'[39m)
[1;32m----> 6[0m rows, cols [38;5;241m=[39m [43mimg[49m[38;5;241;43m.[39;49m[43mshape[49m[:[38;5;241m2[39m]
[0;32m      7[0m cv2[38;5;241m.[39mimshow([38;5;124m'[39m[38;5;124moriginal[39m[38;5;124m'[39m, img)
[0;32m     10[0m [38;5;66;03m# ë™ì „ í‘œë©´ì„ íë¦¿í•˜ê²Œ í”¼ë¼ë¯¸ë“œí‰ê· ì‹œí”„íŠ¸ ì ìš©[39;00m

[1;31mAttributeError[0m: 'NoneType' object has no attribute 'shape'
AttributeError: 'NoneType' object has no attribute 'shape'

