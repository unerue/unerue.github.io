Traceback (most recent call last):
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\jupyter_cache\executors\utils.py", line 51, in single_nb_execution
    executenb(
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "C:\Users\unerue\miniconda3\envs\vision\lib\asyncio\base_events.py", line 642, in run_until_complete
    return future.result()
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\unerue\miniconda3\envs\vision\lib\site-packages\nbclient\client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import torch
from torchvision.ops import nms, box_iou
from sklearn.svm import LinearSVC


def _xywh_to_xyxy(box):
    x, y, w, h = box
    return x, y, x + w, y + h


class RegionsCNN(nn.Module):
    def __init__(self, num_classes=20, max_size=227):
        super().__init__()
        self.max_size = max_size
        self.region_proposal = SelectiveSearch(min_size=50)
        feature_extractor = models.alexnet(pretrained=True)
        feature_extractor.classifier[-1] = nn.Linear(feature_extractor.classifier[-1].in_features, 2)
        self.feature_extractor = feature_extractor

        self.classifier = LinearSVC()
        self.regressor = nn.Linear(256 * 6 * 6, 4)
        
    def forward(self, images):
        _, regions = self.region_proposal(images)
        
        
        if self.training:
            positives = []
            negatives = []
            # compute ious
            # dict to list modify selective search returns
            regions = torch.tensor(list(regions), dtype=torch.int64)
            gt = torch.tensor([[50, 50, 150, 150]], dtype=torch.int64)
            
            ious = box_iou(regions, gt)
            
            for i in range(len(ious)):
                xmin, ymin, xmax, ymax = regions[i]
                iou_score = ious[i]
                if 0 < iou_score <= 0.3:
                    negatives.append(regions[i])
                elif iou_score >= 0.5:
                    positives.append(regions[i])
                    
            print(negatives)
            print()
            print(positives)
            
            for positive in positives:
                xmin, ymin, xmax, ymax = _xywh_to_xyxy(positive)  # return x, y, w, h
                warp_image = images[ymin:ymax, xmin:xmax]  # H, W, C
                warp_image = transform(warp_image)  # C, H, W
                feature = self.feature_extractor.features(warp_image.unsqueeze(0)) # [?, ?]
                feature = torch.flatten(feature, 1)

                self.classifier.fit(feature, targets)
                outputs = self.regressor(feature)
                print(outputs)
                            
        else:
            scores = []
            positives = []
            for region in regions:
                xmin, ymin, xmax, ymax = _xywh_to_xyxy(region)  # return x, y, w, h
                warp_image = images[ymin:ymax, xmin:xmax]  # H, W, C
                warp_image = transform(warp_image)  # C, H, W
                output = self.feature_extractor(warp_image.unsqueeze(0))[0] # [?, ?]
                
                boxes = self.regressor(feature)
                
                if torch.argmax(output).item() == 1:
                    probs = torch.softmax(output, dim=0)#.cpu().numpy()
                    if probs[1] >= 0.3:
                        scores.append(probs[1])
                        positives.append([xmin, ymin, xmax, ymax])

            positives = torch.tensor(positives, dtype=torch.float32)
            print(positives.size())
            scores = torch.FloatTensor(scores)
            results = nms(positives, scores, iou_threshold=0.3)
            print(results.size())
            print(positives[results])
                

rcnn = RegionsCNN().train()
img = data.astronaut()
print(img.shape)  # skimnage h, w, depth
rcnn(img)
------------------

[1;31m---------------------------------------------------------------------------[0m
[1;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Input [1;32mIn [4][0m, in [0;36m<cell line: 3>[1;34m()[0m
[0;32m      1[0m [38;5;28;01mimport[39;00m [38;5;21;01mtorch[39;00m
[0;32m      2[0m [38;5;28;01mfrom[39;00m [38;5;21;01mtorchvision[39;00m[38;5;21;01m.[39;00m[38;5;21;01mops[39;00m [38;5;28;01mimport[39;00m nms, box_iou
[1;32m----> 3[0m [38;5;28;01mfrom[39;00m [38;5;21;01msklearn[39;00m[38;5;21;01m.[39;00m[38;5;21;01msvm[39;00m [38;5;28;01mimport[39;00m LinearSVC
[0;32m      6[0m [38;5;28;01mdef[39;00m [38;5;21m_xywh_to_xyxy[39m(box):
[0;32m      7[0m     x, y, w, h [38;5;241m=[39m box

[1;31mModuleNotFoundError[0m: No module named 'sklearn'
ModuleNotFoundError: No module named 'sklearn'

